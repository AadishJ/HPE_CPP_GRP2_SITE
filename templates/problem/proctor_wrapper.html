{% extends "base.html" %} {% block title %}{{ title }}{% endblock %} {% block
body %}
<style>
  body.proctoring-active {
    overflow: hidden;
  }
  #startup-info {
    max-width: 800px;
    margin: 50px auto;
    text-align: center;
    padding: 50px;
  }
  #proctoring-layout {
    display: flex;
    flex-direction: row;
    width: 100vw;
    height: calc(100vh - 40px);
    position: fixed;
    top: 40px;
    left: 0;
    background: white;
  }
  #dmoj-content-container {
    flex-grow: 1;
    height: 100%;
  }
  #dmoj-problem-frame {
    width: 100%;
    height: 100%;
    border: none;
  }
  #proctoring-sidebar {
    width: 320px;
    flex-shrink: 0;
    background-color: #f8f9fa;
    border-left: 1px solid #dee2e6;
    transition: all 0.3s ease-in-out;
    position: relative;
    display: flex;
    flex-direction: column;
  }
  #proctoring-ui {
    padding: 1em;
  }
  #proctoring-sidebar.collapsed {
    width: 0;
    padding: 0;
    border-left: none;
  }
  #proctoring-sidebar.collapsed > * {
    visibility: hidden;
  }
  #toggle-sidebar-btn {
    position: absolute;
    top: 50%;
    left: 0;
    transform: translateY(-50%) translateX(-100%);
    width: 25px;
    height: 80px;
    border: 1px solid #dee2e6;
    border-right: none;
    background-color: #f8f9fa;
    cursor: pointer;
    font-size: 20px;
    padding: 0;
    border-radius: 15px 0 0 15px;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #555;
  }
  #proctoring-sidebar.collapsed #toggle-sidebar-btn {
    visibility: visible;
    transform: translateY(-50%) translateX(0) scaleX(-1);
    left: -25px;
    border-right: 1px solid #dee2e6;
    border-left: none;
    border-radius: 0 15px 15px 0;
  }
</style>

<div
  id="startup-info"
  data-problem-url="{{ url('problem_detail', problem.code) }}"
>
  <h1>{{ title }}</h1>
  <p>
    You are about to start a proctoring session for problem:
    <strong>{{ problem.name }}</strong>.
  </p>
  <p>Please click the button below to grant camera access and begin.</p>
  <button
    id="startBtn"
    class="button"
    style="padding: 15px 30px; font-size: 1.2em"
  >
    Start Proctoring Session
  </button>
</div>

<div id="proctoring-layout" style="display: none">
  <div id="dmoj-content-container">
    <iframe id="dmoj-problem-frame" src="about:blank"></iframe>
  </div>
  <div id="proctoring-sidebar">
    <button id="toggle-sidebar-btn" title="Toggle Proctoring Panel">â€¹</button>
    <div id="proctoring-ui">
      <h3 style="text-align: center; margin-top: 0; margin-bottom: 15px">
        Proctoring
      </h3>
      <video
        id="webcam"
        autoplay
        muted
        playsinline
        style="width: 100%; background: black; border-radius: 5px"
      ></video>
      <canvas id="canvas" style="display: none"></canvas>
      <div
        id="status"
        style="margin-top: 10px; font-weight: bold; text-align: center"
      >
        Initializing...
      </div>
    </div>
  </div>
</div>

<script>
  {%- raw -%}
  document.addEventListener("DOMContentLoaded", function () {
      // --- UI & Server Configuration ---
      const API_BASE_URL = "http://127.0.0.1:8001";
      const startBtn = document.getElementById("startBtn");
      const startupInfo = document.getElementById("startup-info");
      const proctoringLayout = document.getElementById("proctoring-layout");
      const iframe = document.getElementById("dmoj-problem-frame");
      const sidebar = document.getElementById("proctoring-sidebar");
      const toggleBtn = document.getElementById("toggle-sidebar-btn");
      const video = document.getElementById("webcam");
      const canvas = document.getElementById("canvas");
      const statusDiv = document.getElementById("status");
      const problemUrl = startupInfo.getAttribute('data-problem-url');

      // --- Proctoring State & Config ---
      let socket, mediaRecorder, analysisInterval;
      let recordedChunks = [];
      let isProctoring = false;
      let isFinalizingClip = false;
      const ANALYSIS_INTERVAL_MS = 500;
      const PRE_VIOLATION_BUFFER_SECONDS = 10;
      const POST_VIOLATION_RECORD_SECONDS = 15;

      // --- Event Listeners for UI ---
      if (startBtn) {
          startBtn.addEventListener("click", () => {
              console.log("[DEBUG] Start button clicked.");
              if (!isProctoring) startProctoring();
          });
      }
      if (toggleBtn) {
          toggleBtn.addEventListener("click", () => {
              console.log("[DEBUG] Sidebar toggled.");
              sidebar.classList.toggle("collapsed")
          });
      }
      window.addEventListener("message", (event) => {
          if (event.origin !== window.location.origin || !event.data) return;
          if (event.data.proctoringPage) {
              console.log(`[DEBUG] Iframe navigated to: ${event.data.proctoringPage}`);
          }
          if (event.data.proctoringAction === "end_session") {
              console.log("[DEBUG] Received 'end_session' command from iframe.");
              stopProctoring();
              proctoringLayout.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;"><h1>Session Ended</h1></div>';
              document.body.classList.remove('proctoring-active');
          }
      });

      // --- Core Proctoring Functions with Debugging ---

      async function startProctoring() {
          console.log("[DEBUG] Attempting to start proctoring session...");
          try {
              statusDiv.textContent = 'Requesting camera...';
              const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
              console.log("[DEBUG] Camera access granted.");
              video.srcObject = stream;
              isProctoring = true;

              startupInfo.style.display = "none";
              proctoringLayout.style.display = "flex";
              document.body.classList.add('proctoring-active');
              iframe.src = problemUrl;
              console.log(`[DEBUG] Iframe src set to: ${problemUrl}`);

              initWebSocket();
              initMediaRecorder(stream);
              analysisInterval = setInterval(sendFrameForAnalysis, ANALYSIS_INTERVAL_MS);
          } catch (error) {
              console.error('[DEBUG] Error starting proctoring:', error);
              statusDiv.textContent = 'Could not access camera.';
          }
      }

      function initWebSocket() {
          console.log(`[DEBUG] Initializing WebSocket to: ${API_BASE_URL.replace('http', 'ws')}/ws`);
          socket = new WebSocket(`${API_BASE_URL.replace('http', 'ws')}/ws`);
          socket.onopen = () => {
              console.log("[DEBUG] WebSocket connection opened.");
              statusDiv.textContent = 'Connected to server.';
          };
          socket.onmessage = (event) => {
              const data = JSON.parse(event.data);
              console.log("[DEBUG] WebSocket message received:", data);
              statusDiv.textContent = data.is_compliant ? 'Status: Compliant' : `VIOLATION: ${data.violations.map(v => v.message).join(', ')}`;
              if (data.trigger_upload && !isFinalizingClip) {
                  console.log("[DEBUG] 'trigger_upload' received from server.");
                  statusDiv.textContent = 'Violation detected. Finalizing clip...';
                  finalizeAndUploadClip();
              }
          };
          socket.onclose = (e) => {
              console.log(`[DEBUG] WebSocket closed. Code: ${e.code}`);
              if (isProctoring) stopProctoring();
          };
          socket.onerror = (error) => {
              console.error("[DEBUG] WebSocket error:", error);
              if (isProctoring) stopProctoring();
          };
      }

      function initMediaRecorder(stream) {
          console.log("[DEBUG] Initializing MediaRecorder.");
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
          mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                  recordedChunks.push(event.data);
                  if (!isFinalizingClip) {
                      const totalSeconds = recordedChunks.length;
                      if (totalSeconds > PRE_VIOLATION_BUFFER_SECONDS) {
                          const removedCount = totalSeconds - PRE_VIOLATION_BUFFER_SECONDS;
                          recordedChunks.splice(0, removedCount);
                      }
                  }
              }
          };
          mediaRecorder.onstop = async () => {
              console.log("[DEBUG] MediaRecorder stopped. Processing chunks...");
              const clipBlob = new Blob(recordedChunks, { type: 'video/webm' });
              if (clipBlob.size > 0) {
                  console.log(`[DEBUG] Uploading clip of size: ${clipBlob.size}`);
                  const formData = new FormData();
                  formData.append('file', clipBlob, `violation.webm`);
                  try {
                      await fetch(`${API_BASE_URL}/upload-clip`, { method: 'POST', body: formData });
                      console.log("[DEBUG] Upload request sent.");
                  } catch (error) { console.error('[DEBUG] Upload fetch error:', error); }
              }
              recordedChunks = [];
              isFinalizingClip = false;
              if (isProctoring) {
                  console.log("[DEBUG] Restarting MediaRecorder.");
                  mediaRecorder.start(1000);
              }
          };
          mediaRecorder.start(1000);
          console.log("[DEBUG] MediaRecorder started.");
      }

      function sendFrameForAnalysis() {
          if (socket && socket.readyState === WebSocket.OPEN) {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
              socket.send(canvas.toDataURL('image/jpeg', 0.5).split(',')[1]);
          }
      }

      function finalizeAndUploadClip() {
          if (isFinalizingClip) return;
          console.log(`[DEBUG] Finalizing clip. Recording for ${POST_VIOLATION_RECORD_SECONDS} more seconds.`);
          isFinalizingClip = true;
          setTimeout(() => {
              if (mediaRecorder && mediaRecorder.state === 'recording') {
                  console.log("[DEBUG] Stopping MediaRecorder to trigger upload.");
                  mediaRecorder.stop();
              }
          }, POST_VIOLATION_RECORD_SECONDS * 1000);
      }

      function stopProctoring() {
          if (!isProctoring) return;
          console.log("[DEBUG] Stopping proctoring session and cleaning up resources.");
          isProctoring = false;
          clearInterval(analysisInterval);
          if (socket) socket.close();
          if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
          if (video.srcObject) video.srcObject.getTracks().forEach(track => track.stop());
      }
  });
  {%- endraw -%}
</script>
{% endblock %}
